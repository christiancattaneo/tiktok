import 'dart:io' if (dart.library.html) 'dart:html';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:firebase_storage/firebase_storage.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:uuid/uuid.dart';
import 'package:image_picker/image_picker.dart';
import '../models/video.dart';
import '../models/comment.dart';
import 'package:path/path.dart' as path;
import 'package:video_player/video_player.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:cloud_functions/cloud_functions.dart';
import 'package:collection/collection.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'hashtag_service.dart';

class VideoService {
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseFunctions _functions = FirebaseFunctions.instanceFor(region: 'us-central1');
  final _uuid = const Uuid();
  final _hashtagService = HashtagService();
  int _currentPexelsPage = 1;
  bool _isLoadingPexels = false;
  
  // Use this getter for API key
  String get _pexelsApiKey => dotenv.env['PEXELS_API_KEY'] ?? '';

  // Track initial load and shuffled order
  bool _isInitialLoad = true;
  List<String> _shuffledVideoOrder = [];

  // Upload video file to Firebase Storage
  Future<Map<String, String>?> uploadVideo(XFile videoFile, String userId) async {
    try {
      // Generate a unique ID for the video
      final videoId = _uuid.v4();
      
      // Debug logging
      print('Original video file path: ${videoFile.path}');
      print('Original video file name: ${videoFile.name}');
      
      // Get the extension from the file name for web support
      final extension = path.extension(videoFile.name).toLowerCase().replaceAll('.', '');
      print('Detected extension: $extension');
      
      // Map the extension to the correct content type
      final contentType = switch (extension) {
        'mp4' || 'mpeg4' || 'mpeg-4' || 'm4v' => 'video/mp4',
        'mov' || 'qt' || 'quicktime' => 'video/quicktime',
        'avi' => 'video/x-msvideo',
        'mkv' || 'matroska' => 'video/x-matroska',
        _ => 'video/mp4', // Default to mp4 if unknown
      };
      print('Using content type: $contentType');

      // Always store with .mp4 extension for better compatibility
      final videoRef = _storage.ref().child('videos/$userId/$videoId.mp4');
      print('Storage reference path: ${videoRef.fullPath}');

      // Upload the video file with metadata
      final metadata = SettableMetadata(
        contentType: contentType,
        customMetadata: {
          'originalExtension': extension,
          'uploadedAt': DateTime.now().toIso8601String(),
          'platform': kIsWeb ? 'web' : 'mobile',
          'requiresThumbnail': 'true', // Flag for Cloud Function to generate thumbnail
        },
      );

      print('Starting upload with metadata: ${metadata.contentType}');
      
      // Read the file as bytes
      final Uint8List bytes = await videoFile.readAsBytes();
      print('File read as bytes. Size: ${bytes.length} bytes');

      // Upload the video
      final uploadTask = videoRef.putData(bytes, metadata);
      print('Upload task created');

      final snapshot = await uploadTask;
      print('Upload completed. Size: ${snapshot.totalBytes} bytes');

      // Get the video download URL
      final videoUrl = await snapshot.ref.getDownloadURL();
      print('Video URL generated: $videoUrl');

      // Return without thumbnail URL - it will be generated by Cloud Function
      return {
        'videoUrl': videoUrl,
        'thumbnailUrl': '',  // Return empty string instead of null
      };
    } catch (e, stackTrace) {
      print('Error uploading video: $e');
      print('Stack trace: $stackTrace');
      return null;
    }
  }

  // Create video metadata in Firestore
  Future<bool> createVideoMetadata({
    required String userId,
    required String videoUrl,
    required String caption,
    required String creatorUsername,
    String? creatorPhotoUrl,
    String? thumbnailUrl,
    List<String> hashtags = const [],
  }) async {
    try {
      print('Creating video metadata:');
      print('- userId: $userId');
      print('- videoUrl: $videoUrl');
      print('- caption: $caption');
      print('- username: $creatorUsername');
      print('- hashtags: $hashtags');
      
      final data = {
        'userId': userId,
        'creatorUsername': creatorUsername,
        'creatorPhotoUrl': creatorPhotoUrl,
        'videoUrl': videoUrl,
        'caption': caption,
        'thumbnailUrl': thumbnailUrl ?? '',
        'hashtags': hashtags,
        'likes': 0,
        'views': 0,
        'commentCount': 0,
        'isPexels': false,  // Explicitly mark as user-created
        'isSearchGenerated': false,  // Explicitly mark as not search-generated
        'createdAt': FieldValue.serverTimestamp(),
      };
      
      final videoDoc = await _firestore.collection('videos').add(data);
      print('Created video document with ID: ${videoDoc.id}');

      // Verify the document was created
      final verifyDoc = await videoDoc.get();
      if (!verifyDoc.exists) {
        print('Error: Video document not found after creation');
        return false;
      }
      
      print('Video metadata created successfully');
      return true;
    } catch (e, stackTrace) {
      print('Error creating video metadata: $e');
      print('Stack trace: $stackTrace');
      return false;
    }
  }

  // Get videos for feed
  Stream<List<Video>> getVideoFeed() {
    print('üé• Getting video feed...');
    return _firestore
        .collection('videos')
        .snapshots()
        .asyncMap((snapshot) async {
          final allVideos = snapshot.docs.map((doc) => Video.fromFirestore(doc)).toList();
          print('üé• Feed loaded ${allVideos.length} total videos');
          
          // If we have fewer than 10 videos total, fetch more Pexels videos
          if (allVideos.length < 10) {
            print('üé• Fetching more Pexels videos to fill feed');
            try {
              final newPexelsVideos = await fetchPexelsVideos();
              if (newPexelsVideos.isNotEmpty) {
                allVideos.addAll(newPexelsVideos);
                print('üé• Added ${newPexelsVideos.length} new Pexels videos to feed');
              }
            } catch (e) {
              print('üé• Error fetching Pexels videos: $e');
            }
          }
          
          // Only shuffle and store order on initial load
          if (_isInitialLoad) {
            print('üé• Initial load - shuffling videos');
            allVideos.shuffle();
            _shuffledVideoOrder = allVideos.map((v) => v.id).toList();
            _isInitialLoad = false;
          } else {
            // Sort according to stored shuffle order
            allVideos.sort((a, b) {
              final aIndex = _shuffledVideoOrder.indexOf(a.id);
              final bIndex = _shuffledVideoOrder.indexOf(b.id);
              // New videos go at the end
              if (aIndex == -1) return 1;
              if (bIndex == -1) return -1;
              return aIndex.compareTo(bIndex);
            });
          }
          
          print('üé• Returning ${allVideos.length} videos in stable order');
          return allVideos;
        });
  }

  // Get videos from followed users
  Stream<List<Video>> getFollowingVideoFeed(String userId) {
    if (userId.isEmpty) {
      return Stream.value([]);
    }

    return _firestore
        .collection('users')
        .doc(userId)
        .collection('following')
        .snapshots()
        .asyncMap((followingSnapshot) async {
          final followedUserIds = followingSnapshot.docs.map((doc) => doc.id).toList();
          
          if (followedUserIds.isEmpty) {
            return [];
          }

          // Get videos from followed users
          final videoSnapshot = await _firestore
              .collection('videos')
              .where('userId', whereIn: followedUserIds)
              .orderBy('createdAt', descending: true)
              .limit(20)
              .get();

          final videos = videoSnapshot.docs.map((doc) => Video.fromFirestore(doc)).toList();
          print('Following feed loaded ${videos.length} videos');
          return videos;
        });
  }

  // Delete video
  Future<bool> deleteVideo(String videoId, String userId) async {
    try {
      // Delete from Firestore
      await _firestore.collection('videos').doc(videoId).delete();

      // Delete from Storage
      await _storage.ref().child('videos/$userId/$videoId.mp4').delete();

      return true;
    } catch (e) {
      print('Error deleting video: $e');
      return false;
    }
  }

  // Get a single video by ID
  Future<Video?> getVideoById(String videoId) async {
    final doc = await _firestore.collection('videos').doc(videoId).get();
    if (doc.exists) {
      return Video.fromFirestore(doc);
    }
    return null;
  }

  // Update video like count
  Future<void> updateLikeCount(String videoId, int increment) async {
    await _firestore.collection('videos').doc(videoId).update({
      'likes': FieldValue.increment(increment),
    });
  }

  // Update video comment count
  Future<void> updateCommentCount(String videoId, int increment) async {
    await _firestore.collection('videos').doc(videoId).update({
      'commentCount': FieldValue.increment(increment),
    });
  }

  // Search videos by caption
  Future<List<Video>> searchVideos(String query) async {
    print('üîç Searching videos with query: $query');
    
    try {
      // First get user videos that match the query
      final userVideosSnapshot = await _firestore
          .collection('videos')
          .where('caption', isGreaterThanOrEqualTo: query.toLowerCase())
          .where('caption', isLessThan: query.toLowerCase() + 'z')
          .orderBy('caption')
          .orderBy('createdAt', descending: true)
          .get();
      
      final userVideos = userVideosSnapshot.docs.map((doc) => Video.fromFirestore(doc)).toList();
      print('üîç Found ${userVideos.length} user videos');

      // Then fetch Pexels videos with the same search query
      final pexelsVideos = await fetchPexelsVideos(searchQuery: query);
      print('üîç Found ${pexelsVideos.length} Pexels videos');

      // Combine both lists
      final allVideos = [...userVideos, ...pexelsVideos];
      
      // Sort by creation date to mix them together
      allVideos.sort((a, b) {
        final aDate = a.createdAt ?? DateTime.fromMillisecondsSinceEpoch(0);
        final bDate = b.createdAt ?? DateTime.fromMillisecondsSinceEpoch(0);
        return bDate.compareTo(aDate); // Newest first
      });
      
      print('üîç Returning ${allVideos.length} total videos');
      return allVideos;
    } catch (e) {
      print('üîç Error searching videos: $e');
      return [];
    }
  }

  // Toggle like on a video
  Future<bool> toggleLike(String videoId, String userId) async {
    final videoRef = _firestore.collection('videos').doc(videoId);
    final userLikesRef = _firestore.collection('users').doc(userId).collection('likes').doc(videoId);

    try {
      bool isLiked = false;
      await _firestore.runTransaction((transaction) async {
        final videoDoc = await transaction.get(videoRef);
        final userLikeDoc = await transaction.get(userLikesRef);

        if (!videoDoc.exists) {
          throw Exception('Video not found');
        }

        if (userLikeDoc.exists) {
          // User has already liked the video - remove like
          transaction.delete(userLikesRef);
          transaction.update(videoRef, {
            'likes': FieldValue.increment(-1),
          });
          isLiked = false;
        } else {
          // User hasn't liked the video - add like
          transaction.set(userLikesRef, {
            'timestamp': FieldValue.serverTimestamp(),
          });
          transaction.update(videoRef, {
            'likes': FieldValue.increment(1),
          });
          isLiked = true;
        }
      });
      return isLiked;
    } catch (e) {
      print('Error toggling like: $e');
      return false;
    }
  }

  // Check if user has liked a video
  Future<bool> hasUserLikedVideo(String videoId, String userId) async {
    try {
      final doc = await _firestore
          .collection('users')
          .doc(userId)
          .collection('likes')
          .doc(videoId)
          .get();
      return doc.exists;
    } catch (e) {
      print('Error checking like status: $e');
      return false;
    }
  }

  // Get all videos liked by a user
  Stream<List<String>> getUserLikedVideoIds(String userId) {
    return _firestore
        .collection('users')
        .doc(userId)
        .collection('likes')
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => doc.id).toList());
  }

  // Add a comment to a video
  Future<Comment?> addComment({
    required String videoId,
    required String userId,
    required String username,
    required String text,
    String? userPhotoUrl,
    String? gifUrl,
    String? gifId,
  }) async {
    try {
      print('Creating comment with photo URL: $userPhotoUrl');
      print('Creating comment with GIF URL: $gifUrl');
      
      final commentRef = _firestore
          .collection('videos')
          .doc(videoId)
          .collection('comments')
          .doc();

      final comment = Comment(
        id: commentRef.id,
        videoId: videoId,
        userId: userId,
        username: username,
        userPhotoUrl: userPhotoUrl,
        text: text,
        gifUrl: gifUrl,
        gifId: gifId,
        likes: 0,
        likedByCreator: false,
        createdAt: DateTime.now(),
      );

      print('Comment object created');
      final map = comment.toMap();
      print('Comment map for Firestore: $map');

      await commentRef.set(map);

      // Update comment count
      await _firestore.collection('videos').doc(videoId).update({
        'commentCount': FieldValue.increment(1),
      });

      return comment;
    } catch (e) {
      print('Error adding comment: $e');
      return null;
    }
  }

  // Get comments for a video
  Stream<List<Comment>> getVideoComments(String videoId) {
    return _firestore
        .collection('videos')
        .doc(videoId)
        .collection('comments')
        .orderBy('createdAt', descending: false)
        .snapshots()
        .map((snapshot) {
          print('Retrieved ${snapshot.docs.length} comments');
          final comments = snapshot.docs.map((doc) {
            final data = doc.data();
            print('Comment data from Firestore: $data');
            return Comment.fromFirestore(doc);
          }).toList();
          print('Mapped comments with photo URLs: ${comments.map((c) => c.userPhotoUrl)}');
          return comments;
        });
  }

  // Delete a comment
  Future<bool> deleteComment(String videoId, String commentId) async {
    try {
      await _firestore
          .collection('videos')
          .doc(videoId)
          .collection('comments')
          .doc(commentId)
          .delete();

      await _firestore.collection('videos').doc(videoId).update({
        'commentCount': FieldValue.increment(-1),
      });

      return true;
    } catch (e) {
      print('Error deleting comment: $e');
      return false;
    }
  }

  // Toggle like on a comment
  Future<bool> toggleCommentLike(String videoId, String commentId, String userId) async {
    final commentRef = _firestore
        .collection('videos')
        .doc(videoId)
        .collection('comments')
        .doc(commentId);
    final userLikesRef = _firestore
        .collection('users')
        .doc(userId)
        .collection('commentLikes')
        .doc(commentId);
    final videoRef = _firestore.collection('videos').doc(videoId);

    try {
      bool isLiked = false;
      await _firestore.runTransaction((transaction) async {
        final commentDoc = await transaction.get(commentRef);
        final userLikeDoc = await transaction.get(userLikesRef);
        final videoDoc = await transaction.get(videoRef);

        if (!commentDoc.exists || !videoDoc.exists) {
          throw Exception('Comment or video not found');
        }

        final videoData = videoDoc.data() as Map<String, dynamic>;
        final isCreator = videoData['userId'] == userId;

        if (userLikeDoc.exists) {
          // User has already liked the comment - remove like
          transaction.delete(userLikesRef);
          transaction.update(commentRef, {
            'likes': FieldValue.increment(-1),
            if (isCreator) 'likedByCreator': false,
          });
          isLiked = false;
        } else {
          // User hasn't liked the comment - add like
          transaction.set(userLikesRef, {
            'timestamp': FieldValue.serverTimestamp(),
          });
          transaction.update(commentRef, {
            'likes': FieldValue.increment(1),
            if (isCreator) 'likedByCreator': true,
          });
          isLiked = true;
        }
      });
      return isLiked;
    } catch (e) {
      print('Error toggling comment like: $e');
      return false;
    }
  }

  // Check if user has liked a comment
  Future<bool> hasUserLikedComment(String commentId, String userId) async {
    try {
      final doc = await _firestore
          .collection('users')
          .doc(userId)
          .collection('commentLikes')
          .doc(commentId)
          .get();
      return doc.exists;
    } catch (e) {
      print('Error checking comment like status: $e');
      return false;
    }
  }

  // Get videos created by a user
  Stream<List<Video>> getUserVideos(String userId) {
    return _firestore
        .collection('videos')
        .where('userId', isEqualTo: userId)
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => Video.fromFirestore(doc)).toList());
  }

  // Get videos liked by a user
  Stream<List<Video>> getUserLikedVideos(String userId) {
    return _firestore
        .collection('users')
        .doc(userId)
        .collection('likes')
        .orderBy('timestamp', descending: true)
        .snapshots()
        .asyncMap((snapshot) async {
          final videoIds = snapshot.docs.map((doc) => doc.id).toList();
          if (videoIds.isEmpty) return [];

          // Get all videos in a single batch
          final videoDocs = await Future.wait(
            videoIds.map((id) => _firestore.collection('videos').doc(id).get())
          );

          // Filter out any deleted videos and map to Video objects
          return videoDocs
              .where((doc) => doc.exists)
              .map((doc) => Video.fromFirestore(doc))
              .toList();
        });
  }

  Future<void> incrementViews(String videoId) async {
    try {
      await _firestore.collection('videos').doc(videoId).update({
        'views': FieldValue.increment(1),
      });
    } catch (e) {
      print('Error incrementing views: $e');
    }
  }

  // Delete all sample videos
  Future<void> deleteSampleVideos() async {
    try {
      final snapshot = await _firestore
          .collection('videos')
          .where('userId', isEqualTo: 'placeholder_user')
          .get();

      final batch = _firestore.batch();
      for (var doc in snapshot.docs) {
        batch.delete(doc.reference);
      }
      await batch.commit();
      print('Successfully deleted ${snapshot.docs.length} sample videos');
    } catch (e) {
      print('Error deleting sample videos: $e');
    }
  }

  Future<List<Video>> fetchPexelsVideos({
    String? searchQuery,
    DateTime? lastVideoTimestamp,
  }) async {
    if (_isLoadingPexels) return [];
    _isLoadingPexels = true;

    try {
      final isSearching = searchQuery?.isNotEmpty == true;
      final baseUrl = isSearching
          ? 'https://api.pexels.com/videos/search'
          : 'https://api.pexels.com/videos/popular';
      
      print('üé• Fetching Pexels videos from: ${isSearching ? 'search' : 'popular'} endpoint');
      
      final queryParams = {
        'per_page': '10',
        'page': _currentPexelsPage.toString(),
      };
      
      if (isSearching) {
        queryParams['query'] = searchQuery!;
      }
      
      final uri = Uri.parse(baseUrl).replace(queryParameters: queryParams);
      print('üé• Pexels API URL: $uri');
      
      final response = await http.get(
        uri,
        headers: {
          'Authorization': _pexelsApiKey,
        },
      );

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final videos = data['videos'] as List;
        if (videos.isEmpty) {
          print('üé• No videos returned from Pexels API');
          _isLoadingPexels = false;
          return [];
        }
        _currentPexelsPage++;

        final List<Video> processedVideos = [];
        final now = DateTime.now();
        
        for (var video in videos) {
          try {
            // Get the best quality video file
            final videoFile = video['video_files'].firstWhere(
              (f) => f['quality'] == 'hd' && f['width'] >= 720,
              orElse: () => video['video_files'].first,
            );

            final pexelsUrl = videoFile['link'];
            final userId = 'pexels_${video['user']['id']}';
            final username = video['user']['name'];
            final description = video['url'].split('/').last.replaceAll('-', ' ');
            final videoId = _uuid.v4();
            
            // Create a timestamp slightly before now for each video
            final timestamp = now.subtract(Duration(seconds: processedVideos.length));

            // Check if video already exists
            final existingVideos = await _firestore
                .collection('videos')
                .where('pexelsId', isEqualTo: video['id'].toString())
                .limit(1)
                .get();

            if (existingVideos.docs.isNotEmpty) {
              print('üé• Video already exists in Firestore, skipping: ${video['id']}');
              continue;
            }

            // Download video from Pexels
            print('üé• Downloading video from Pexels: $pexelsUrl');
            final videoResponse = await http.get(Uri.parse(pexelsUrl));
            if (videoResponse.statusCode != 200) {
              print('üé• Error downloading video from Pexels: ${videoResponse.statusCode}');
              continue;
            }

            // Upload to Firebase Storage
            final videoRef = _storage.ref().child('videos/$userId/$videoId.mp4');
            final metadata = SettableMetadata(
              contentType: 'video/mp4',
              customMetadata: {
                'source': 'pexels',
                'pexelsId': video['id'].toString(),
                'uploadedAt': timestamp.toIso8601String(),
              },
            );

            await videoRef.putData(videoResponse.bodyBytes, metadata);
            final videoUrl = await videoRef.getDownloadURL();

            // Generate hashtags using Cloud Functions
            print('üé• Generating hashtags for video: $videoUrl');
            final hashtags = await _generateHashtags(videoUrl, description);
            print('üé• Generated hashtags: $hashtags');

            final videoDoc = await _firestore.collection('videos').add({
              'userId': userId,
              'creatorUsername': username,
              'videoUrl': videoUrl,
              'caption': isSearching 
                  ? '#${searchQuery?.replaceAll(' ', '')} from Pexels'
                  : description,
              'thumbnailUrl': video['image'],
              'hashtags': hashtags,
              'likes': 0,
              'views': 0,
              'commentCount': 0,
              'createdAt': Timestamp.fromDate(timestamp),
              'isPexels': true,
              'pexelsId': video['id'].toString(),
              'isSearchGenerated': isSearching,
              'duration': video['duration'],
              'width': videoFile['width'],
              'height': videoFile['height'],
            });

            final newVideo = Video.fromFirestore(await videoDoc.get());
            processedVideos.add(newVideo);
            print('üé• Successfully added Pexels video: ${newVideo.id}');

          } catch (e) {
            print('üé• Error processing Pexels video: $e');
            continue;
          }
        }

        _isLoadingPexels = false;
        print('üé• Successfully processed ${processedVideos.length} Pexels videos');
        return processedVideos;
      } else {
        print('üé• Pexels API error: ${response.statusCode}');
        _isLoadingPexels = false;
        return [];
      }
    } catch (e) {
      print('üé• Error fetching Pexels videos: $e');
      _isLoadingPexels = false;
      return [];
    }
  }

  Future<List<String>> _generateHashtags(String videoUrl, String description) async {
    return _hashtagService.generateHashtags(videoUrl, description);
  }

  // Check if we have any videos
  Future<bool> checkForVideos() async {
    try {
      final snapshot = await _firestore
          .collection('videos')
          .limit(1)
          .get();
      return snapshot.docs.isNotEmpty;
    } catch (e) {
      print('Error checking for videos: $e');
      return false;
    }
  }

  // Update video hashtags
  Future<void> updateVideoHashtags(String videoId, List<String> newHashtags) async {
    try {
      print('üè∑Ô∏è Updating hashtags for video $videoId with: $newHashtags');
      await _firestore.collection('videos').doc(videoId).update({
        'hashtags': newHashtags
      });
      print('üè∑Ô∏è Successfully updated hashtags for video $videoId: $newHashtags');
    } catch (e, stackTrace) {
      print('Error updating hashtags: $e');
      print('Stack trace: $stackTrace');
    }
  }

  // Enrich video hashtags using Cloud Function
  Future<void> enrichVideoHashtags(Video video) async {
    // Temporarily disabled Cloud Function calls
    return;
    
    // if (!video.isPexels) return; // Only process Pexels videos
    
    // try {
    //   print('ü§ñ Enriching hashtags for video: ${video.id}');
      
    //   // Call the Cloud Function
    //   final callable = _functions.httpsCallable('generateHashtags');
    //   final result = await callable.call({
    //     'videoUrl': video.videoUrl,
    //     'description': video.caption,
    //     'thumbnailUrl': video.thumbnailUrl,
    //   });
      
    //   final hashtags = List<String>.from(result.data['hashtags'] ?? []);
      
    //   // Only update if we got meaningful hashtags
    //   if (hashtags.isNotEmpty && 
    //       hashtags.length > 2 &&  // More than default
    //       !const ListEquality().equals(hashtags, ['pexels', 'video'])) {  // Not default tags
    //     await updateVideoHashtags(video.id, hashtags);
    //     print('ü§ñ Successfully enriched hashtags for video ${video.id} with: $hashtags');
    //   } else {
    //     print('ü§ñ Skipping hashtag update for video ${video.id} - insufficient or default hashtags received');
    //   }
    // } catch (e, stackTrace) {
    //   print('Error enriching hashtags: $e');
    //   print('Stack trace: $stackTrace');
    // }
  }
} 